\section {Arsitektur Komputer}
Dalam teknik komputer, arsitektur komputer adalah seperangkat aturan dan metode yang menggambarkan fungsionalitas, organisasi, dan implementasi sistem komputer. Beberapa definisi arsitektur mendefinisikannya sebagai menggambarkan kemampuan dan model pemrograman komputer namun bukan implementasi tertentu \cite{clements2006principles}. Dalam definisi lain arsitektur komputer melibatkan desain arsitektur set instruksi, desain mikroarsitektur, desain logika, dan implementasi.\cite{hennessy2011computer)
\subsection{Sejarah}
Arsitektur komputer terdokumentasi pertama ada dalam korespondensi antara Charles Babbage dan Ada Lovelace, yang menggambarkan mesin analitis. Saat membangun komputer Z1 pada tahun 1936, Konrad Zuse menjelaskan dalam dua aplikasi paten untuk proyek masa depannya bahwa instruksi mesin dapat disimpan dalam penyimpanan yang sama yang digunakan untuk data, yaitu konsep program tersimpan. \cite{faberkonrad} Dua contoh awal dan penting lainnya adalah:
\begin{itemize}
\item Makalah karya John von Neumann tahun 1945, Draft Pertama Laporan tentang EDVAC, yang menggambarkan sebuah organisasi elemen logis; \cite{von1945first}
\item Kalkulator Elektronik Kalkulator Alan Turing yang lebih rinci untuk Mesin Komputasi Otomatis, juga 1945 dan yang mengutip makalah John von Neumann. \cite{copeland2005alan}
\end{itemize}

Istilah \"arsitektur\" dalam literatur komputer dapat dilacak pada karya Lyle R. Johnson, Frederick P. Brooks, Jr., dan Mohammad Usman Khan, semua anggota departemen Organisasi Mesin di pusat penelitian utama IBM pada tahun 1959. Johnson telah kesempatan untuk menulis sebuah komunikasi riset eksklusif tentang Stretch, sebuah superkomputer yang dikembangkan IBM untuk Laboratorium Nasional Los Alamos (yang saat ini dikenal sebagai Laboratorium Ilmiah Los Alamos). Untuk menggambarkan tingkat detail untuk membahas komputer mewah, dia mencatat bahwa deskripsi format, jenis instruksi, parameter perangkat keras, dan perangkat tambahan kecepatannya berada pada tingkat \"arsitektur sistem\" - istilah yang nampaknya lebih berguna daripada \"organisasi mesin.\"
Arsitektur komputer, seperti arsitektur lainnya, adalah seni untuk menentukan kebutuhan pengguna suatu struktur dan kemudian merancang untuk memenuhi kebutuhan tersebut seefektif mungkin dalam batasan ekonomi dan teknologi.
Brooks melanjutkan untuk membantu mengembangkan IBM System / 360 (sekarang disebut IBM zSeries) baris komputer, di mana \"arsitektur\" menjadi kata benda yang mendefinisikan \"apa yang pengguna perlu ketahui\". Kemudian, pengguna komputer menggunakan istilah ini dengan banyak cara yang kurang eksplisit. \cite{hellige2004genese}
Arsitektur komputer paling awal dirancang di atas kertas dan kemudian langsung dibangun ke dalam bentuk perangkat keras terakhir. \cite{copeland2005alan} Kemudian, prototip arsitektur komputer secara fisik dibangun dalam bentuk komputer logika transistor-transistor (TTL) - seperti prototip dari 6800 dan PA-RISC yang diuji, dan di-tweak, sebelum melakukan sampai pada bentuk perangkat keras terakhir. Pada tahun 1990an, arsitektur komputer baru biasanya \"dibangun\", diuji, dan di-tweak-di dalam beberapa arsitektur komputer lainnya di simulator arsitektur komputer; atau di dalam FPGA sebagai mikroprosesor yang lembut; atau keduanya-sebelum melakukan ke bentuk perangkat keras terakhir. \cite{hellige2004genese}
\subsection{Subkategori}
Disiplin arsitektur komputer memiliki tiga subkategori utama: \cite{hennessy2011computer}
\begin{enumerate}
\item Instruction Set Architecture, atau ISA. ISA mendefinisikan kode mesin yang dibaca dan dijalankan oleh prosesor serta ukuran kata, mode alamat memori, register prosesor, dan tipe data.
\item Arsitektur mikro, atau organisasi komputer menggambarkan bagaimana prosesor tertentu akan menerapkan ISA. \cite{laplante2000dictionary} Ukuran cache CPU komputer misalnya, adalah masalah yang umumnya tidak ada hubungannya dengan ISA.
\item Desain Sistem mencakup semua komponen perangkat keras lainnya dalam sistem komputasi. Ini termasuk:
\begin{itemize}
\item Pengolahan data selain CPU, seperti akses memori langsung (DMA)
\item Masalah lain seperti virtualisasi, multiprocessing, dan fitur perangkat lunak.
\end{itemize}
\end{enumerate}

Ada jenis arsitektur komputer lainnya. Jenis berikut digunakan di perusahaan besar seperti Intel, dan menghitung 1% dari semua arsitektur komputer
\begin{itemize}
\item Makroarsitektur: lapisan arsitektur lebih abstrak dibanding mikroarsitektur
\item Assembly Instruction Set Architecture (ISA): Perakit cerdas dapat mengubah bahasa assembly menjadi implementasi yang berbeda
\item Programmer Visible Macroarchitecture: alat bahasa tingkat yang lebih tinggi seperti ISA, UISA, dan mikroarsitektur ISA, UISA, dan mikroarsitektur. Misalnya. C, C ++, atau standar Java mendefinisikan Programmer Visible Macroarchitecture yang berbeda.
\item UISA (Microcode Instruction Set Architecture) - sekelompok mesin dengan mikroarsitektur tingkat perangkat keras yang berbeda dapat berbagi arsitektur microcode yang umum, dan karenanya merupakan UISA. 
\item Arsitektur Pin: Fungsi perangkat keras yang harus diberikan mikroprosesor ke platform perangkat keras, misalnya pin x86 A20M, FERR / IGNNE atau FLUSH. Juga, pesan yang harus dipancarkan prosesor sehingga cache eksternal bisa tidak berlaku lagi (dikosongkan). Fungsi arsitektur pin lebih fleksibel daripada fungsi ISA karena perangkat keras eksternal dapat beradaptasi dengan pengkodean baru, atau berubah dari pin ke pesan. Istilah \"arsitektur\" cocok, karena fungsinya harus disediakan untuk sistem yang kompatibel, walaupun metode rinci berubah.
\end{itemize}

\subsubsection{Definisi}
Tujuannya adalah untuk merancang komputer yang memaksimalkan kinerja sambil menjaga konsumsi daya tetap terkendali, biaya rendah relatif terhadap jumlah kinerja yang diharapkan, dan juga sangat dapat diandalkan. Untuk ini, banyak aspek yang harus dipertimbangkan yang meliputi desain set instruksi, organisasi fungsional, desain logika, dan implementasi. Implementasinya melibatkan desain sirkuit terpadu, kemasan, tenaga, dan pendinginan. Optimalisasi desain memerlukan keakraban dengan kompiler, sistem operasi untuk desain logika, dan kemasan.

Instruksi set arsitektur 
An instruction set architecture (ISA) adalah antarmuka antara perangkat lunak dan perangkat keras komputer dan juga dapat dipandang sebagai tampilan pemrogram pada mesin. Komputer tidak mengerti bahasa tingkat tinggi seperti Java, C ++, atau sebagian besar bahasa pemrograman yang digunakan. Prosesor hanya memahami instruksi yang dikodekan dalam beberapa mode numerik, biasanya sebagai bilangan biner. Perangkat perangkat lunak, seperti kompiler, terjemahkan bahasa tingkat tinggi itu ke dalam instruksi yang dapat dimengerti oleh prosesor.
Selain instruksi, ISA mendefinisikan item di komputer yang tersedia untuk sebuah program-mis. tipe data, register, mode pengalamatan, dan memori. Petunjuk cari item yang tersedia ini dengan indeks register (atau nama) dan mode pengalamatan memori.
ISA komputer biasanya dijelaskan dalam manual instruksi kecil, yang menjelaskan bagaimana instruksi dikodekan. Juga, ini bisa menentukan nama mnemonik singkat (samar-samar) untuk petunjuknya. Nama-nama itu bisa dikenali dengan alat pengembangan perangkat lunak yang disebut assembler. Perakit adalah program komputer yang menerjemahkan bentuk ISA yang dapat dibaca manusia ke dalam bentuk yang dapat dibaca komputer. Disassembler juga banyak tersedia, biasanya di debugger dan program perangkat lunak untuk mengisolasi dan memperbaiki malfungsi dalam program komputer biner.
ISA bervariasi dalam kualitas dan kelengkapannya. ISA yang baik berkompromi antara kenyamanan programmer (betapa mudahnya kode untuk dipahami), ukuran kode (berapa banyak kode yang diperlukan untuk melakukan tindakan tertentu), biaya komputer untuk menafsirkan instruksi (lebih banyak kerumitan berarti lebih banyak ruang yang dibutuhkan untuk membongkar instruksi), dan kecepatan komputer (dengan disassembler yang lebih besar lagi membongkar waktu lebih lama). Sebagai contoh, ISA instruksi tunggal seperti ISA yang mengurangi satu dari sebuah nilai dan jika nilainya nol maka nilai yang dikembalikan ke nilai yang lebih tinggi keduanya murah, dan cepat, namun ISA seperti itu tidak nyaman atau membantu saat melihat ukuran ISA. Organisasi memori mendefinisikan bagaimana instruksi berinteraksi dengan memori, dan bagaimana memori berinteraksi dengan dirinya sendiri.
Selama perancangan perangkat lunak emulasi (emulator) dapat menjalankan program yang ditulis dalam rangkaian instruksi yang diusulkan. Emulator modern dapat mengukur ukuran, biaya, dan kecepatan untuk menentukan apakah ISA tertentu memenuhi sasarannya.
\subsection(Organisasi computer)
Organisasi komputer membantu mengoptimalkan produk berbasis kinerja. Misalnya, insinyur perangkat lunak perlu mengetahui kekuatan pemrosesan prosesor. Mereka mungkin perlu mengoptimalkan perangkat lunak untuk mendapatkan kinerja terbaik dengan harga terendah. Ini bisa memerlukan analisis yang cukup rinci tentang organisasi komputer. Misalnya, di kartu SD, para perancang mungkin perlu mengatur kartu sehingga data terbanyak bisa diproses dengan cara tercepat.
Organisasi komputer juga membantu merencanakan pemilihan prosesor untuk proyek tertentu. Proyek multimedia mungkin memerlukan akses data yang sangat cepat, sementara mesin virtual mungkin memerlukan interupsi yang cepat. Terkadang tugas-tugas tertentu juga membutuhkan komponen tambahan. Misalnya, komputer yang mampu menjalankan mesin virtual membutuhkan perangkat keras memori virtual sehingga memori komputer virtual yang berbeda dapat tetap terpisah. Organisasi dan fitur komputer juga mempengaruhi konsumsi daya dan biaya prosesor.
\subsection(Implementasi)
Begitu seperangkat instruksi dan arsitektur mikro dirancang, mesin praktis harus dikembangkan. Proses perancangan ini disebut implementasi. Implementasi biasanya tidak dianggap sebagai desain arsitektur, melainkan rekayasa perancangan perangkat keras. Implementasi dapat dipecah menjadi beberapa langkah:
\begin{itemize}
\item Logika Implementasi merancang rangkaian yang dibutuhkan pada tingkat gerbang logika
\item Circuit Implementation melakukan desain tingkat transistor dari elemen dasar (gerbang, multiplekser, kait dll) dan juga beberapa blok yang lebih besar (ALU, cache dll.) Yang dapat diimplementasikan pada tingkat gerbang gerbang, atau bahkan pada tingkat fisik jika desain panggilan untuk itu.
\item Implementasi Fisik menarik sirkuit fisik. Komponen rangkaian yang berbeda ditempatkan di papan lantai chip atau di papan dan kabel yang menghubungkannya dibuat.
\item Validasi Desain menguji komputer secara keseluruhan untuk melihat apakah ia bekerja dalam semua situasi dan semua timing. Setelah proses validasi desain dimulai, desain pada tingkat logika diuji dengan menggunakan emulator logika. Namun, ini biasanya terlalu lambat untuk menjalankan uji realistis. Jadi, setelah melakukan koreksi berdasarkan uji pertama, prototip dibuat menggunakan Field-Programmable Gate-Arrays (FPGAs). Sebagian besar proyek hobi berhenti pada tahap ini. Langkah terakhir adalah menguji prototip sirkuit terpadu. Sirkuit terpadu mungkin memerlukan beberapa perancangan ulang untuk memperbaiki masalah.
\end{itemize}

Untuk CPU, seluruh proses implementasi diatur secara berbeda dan sering disebut sebagai desain CPU.

\subsection{Tujuan desain}
Bentuk sistem komputer yang tepat bergantung pada batasan dan sasaran. Arsitektur komputer biasanya menukar standar, kekuatan versus kinerja, biaya, kapasitas memori, latensi (latency adalah jumlah waktu yang dibutuhkan untuk informasi dari satu node untuk melakukan perjalanan ke sumbernya) dan keseluruhannya. Terkadang pertimbangan lain, seperti fitur, ukuran, berat, kehandalan, dan kemampuan pengembangan juga merupakan faktor.

Skema yang paling umum dilakukan adalah analisis daya yang mendalam dan mencari tahu bagaimana mempertahankan konsumsi daya tetap rendah, sambil mempertahankan kinerja yang memadai.
\subsection{Kinerja}
Kinerja komputer modern sering digambarkan dalam IPC (instruksi per siklus). Ini mengukur efisiensi arsitektur pada setiap frekuensi clock. Karena tingkat yang lebih cepat bisa membuat komputer lebih cepat, ini adalah pengukuran yang berguna. Komputer yang lebih tua memiliki jumlah IPC serendah 0,1 instruksi per siklus. Prosesor modern sederhana mudah dijangkau di dekat 1. Prosesor superscalar bisa mencapai tiga sampai lima IPC dengan menjalankan beberapa instruksi per siklus clock.
Menghitung instruksi bahasa mesin akan menyesatkan karena mereka dapat melakukan berbagai jumlah pekerjaan di ISA yang berbeda. \"Instruksi\" dalam pengukuran standar bukan merupakan hitungan instruksi bahasa mesin ISA yang sebenarnya, namun unit pengukuran, biasanya didasarkan pada kecepatan arsitektur komputer VAX.
Banyak orang biasa mengukur kecepatan komputer dengan clock rate (biasanya di MHz atau GHz). Ini mengacu pada siklus per detik jam utama CPU. Namun, metrik ini agak menyesatkan, karena mesin dengan clock rate yang lebih tinggi mungkin belum tentu memiliki kinerja lebih tinggi. Akibatnya, produsen telah beralih dari kecepatan clock sebagai ukuran kinerja.
Faktor lain mempengaruhi kecepatan, seperti perpaduan antara unit fungsional, kecepatan bus, memori yang tersedia, dan jenis dan urutan instruksi dalam program.
Ada dua jenis kecepatan utama: latency dan throughput. Latency adalah waktu antara awal proses dan penyelesaiannya. Throughput adalah jumlah pekerjaan yang dilakukan per satuan waktu. Interrupt latency adalah waktu respon maksimum yang terjamin dari sistem ke acara elektronik (seperti saat disk drive selesai memindahkan beberapa data).
Kinerja dipengaruhi oleh pilihan desain yang sangat beragam - misalnya, pipelining prosesor biasanya membuat latency lebih buruk, namun membuat throughput lebih baik. Komputer yang mengendalikan mesin biasanya membutuhkan latency interupsi rendah. Komputer ini beroperasi dalam lingkungan real-time dan gagal jika operasi tidak selesai dalam jumlah waktu tertentu. Sebagai contoh, rem anti-lock yang dikendalikan komputer harus mulai mengerem dalam waktu yang dapat diprediksi dan singkat setelah pedal rem dirasakan atau jika rem tidak lagi akan terjadi.
Benchmarking memperhitungkan semua faktor ini dengan mengukur waktu yang dibutuhkan komputer untuk menjalankan serangkaian program uji. Meskipun benchmarking menunjukkan kekuatan, seharusnya tidak bagaimana Anda memilih komputer. Seringkali mesin yang diukur terpisah pada ukuran yang berbeda. Misalnya, satu sistem mungkin menangani aplikasi ilmiah dengan cepat, sementara yang lain mungkin membuat permainan video lebih lancar. Selanjutnya, perancang dapat menargetkan dan menambahkan fitur khusus ke produk mereka, melalui perangkat keras atau perangkat lunak, yang memungkinkan tolok ukur tertentu dijalankan dengan cepat namun tidak menawarkan keuntungan yang serupa dengan tugas umum.

\subsection{Efisiensi daya}
Efisiensi daya adalah pengukuran penting lainnya di komputer modern. Efisiensi daya yang lebih tinggi seringkali dapat diperdagangkan dengan kecepatan lebih rendah atau biaya yang lebih tinggi. Pengukuran khas saat mengacu pada konsumsi daya dalam arsitektur komputer adalah MIPS / W (jutaan instruksi per detik per watt).
Sirkuit modern memiliki daya yang dibutuhkan lebih sedikit per transistor karena jumlah transistor per chip tumbuh. \cite{haberecht1969integrated} Ini karena setiap transistor yang dimasukkan ke dalam chip baru membutuhkan catu daya sendiri dan membutuhkan jalur baru yang akan dibangun untuk menyalakannya. Namun jumlah transistor per chip mulai meningkat pada tingkat yang lebih lambat. Oleh karena itu, efisiensi daya mulai menjadi penting, jika tidak lebih penting daripada menyesuaikan lebih dan lebih banyak transistor menjadi satu chip tunggal. Desain prosesor terbaru telah menunjukkan penekanan ini karena mereka lebih fokus pada efisiensi daya daripada menjejalkan sebanyak mungkin transistor ke dalam satu chip tunggal. Di dunia komputer tersemat, efisiensi daya telah lama menjadi tujuan penting disamping throughput dan latency.

\subsection{Pergeseran permintaan pasar}
Peningkatan tingkat refresh yang dirilis secara publik telah berkembang perlahan dalam beberapa tahun terakhir, sehubungan dengan lompatan besar dalam pengurangan konsumsi daya dan permintaan miniaturisasi. Hal ini telah menyebabkan permintaan baru akan masa pakai baterai yang lebih lama dan pengurangan ukuran karena teknologi seluler diproduksi dengan kecepatan lebih tinggi. Perubahan fokus dari refresh rate yang lebih besar ke konsumsi daya dan miniaturisasi dapat ditunjukkan dengan pengurangan konsumsi daya yang signifikan, sebanyak 50%, yang dilaporkan oleh Intel dalam peluncuran mikroarsitektur Haswell; dimana mereka menurunkan benchmark konsumsi daya mereka dari 30-40 watt menjadi 10-20 watt. \cite{huck2011measuring} Membandingkan ini dengan kecepatan pemrosesan 3 GHz sampai 4 GHz (2002 sampai 2006) dapat dilihat bahwa fokus dalam penelitian dan pengembangan beralih dari tingkat penyegaran dan bergerak menuju konsumsi daya yang lebih sedikit dan menghabiskan lebih sedikit ruang.


